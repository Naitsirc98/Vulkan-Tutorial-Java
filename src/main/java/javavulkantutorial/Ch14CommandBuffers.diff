diff --git a/Ch13Framebuffers.java b/Ch14CommandBuffers.java
index 38cf106..b444d5c 100644
--- a/Ch13Framebuffers.java
+++ b/Ch14CommandBuffers.java
@@ -28,7 +28,7 @@ import static org.lwjgl.vulkan.KHRSurface.*;
 import static org.lwjgl.vulkan.KHRSwapchain.*;
 import static org.lwjgl.vulkan.VK10.*;
 
-public class Ch13Framebuffers {
+public class Ch14CommandBuffers {
 
     private static class HelloTriangleApplication {
 
@@ -134,6 +134,9 @@ public class Ch13Framebuffers {
         private long pipelineLayout;
         private long graphicsPipeline;
 
+        private long commandPool;
+        private List<VkCommandBuffer> commandBuffers;
+
         // ======= METHODS ======= //
 
         public void run() {
@@ -172,6 +175,8 @@ public class Ch13Framebuffers {
             createRenderPass();
             createGraphicsPipeline();
             createFramebuffers();
+            createCommandPool();
+            createCommandBuffers();
         }
 
         private void mainLoop() {
@@ -184,6 +189,8 @@ public class Ch13Framebuffers {
 
         private void cleanup() {
 
+            vkDestroyCommandPool(device, commandPool, null);
+
             swapChainFramebuffers.forEach(framebuffer -> vkDestroyFramebuffer(device, framebuffer, null));
 
             vkDestroyPipeline(device, graphicsPipeline, null);
@@ -703,6 +710,93 @@ public class Ch13Framebuffers {
             }
         }
 
+        private void createCommandPool() {
+
+            try(MemoryStack stack = stackPush()) {
+
+                QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);
+
+                VkCommandPoolCreateInfo poolInfo = VkCommandPoolCreateInfo.callocStack(stack);
+                poolInfo.sType(VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO);
+                poolInfo.queueFamilyIndex(queueFamilyIndices.graphicsFamily);
+
+                LongBuffer pCommandPool = stack.mallocLong(1);
+
+                if (vkCreateCommandPool(device, poolInfo, null, pCommandPool) != VK_SUCCESS) {
+                    throw new RuntimeException("Failed to create command pool");
+                }
+
+                commandPool = pCommandPool.get(0);
+            }
+        }
+
+        private void createCommandBuffers() {
+
+            final int commandBuffersCount = swapChainFramebuffers.size();
+
+            commandBuffers = new ArrayList<>(commandBuffersCount);
+
+            try(MemoryStack stack = stackPush()) {
+
+                VkCommandBufferAllocateInfo allocInfo = VkCommandBufferAllocateInfo.callocStack(stack);
+                allocInfo.sType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO);
+                allocInfo.commandPool(commandPool);
+                allocInfo.level(VK_COMMAND_BUFFER_LEVEL_PRIMARY);
+                allocInfo.commandBufferCount(commandBuffersCount);
+
+                PointerBuffer pCommandBuffers = stack.mallocPointer(commandBuffersCount);
+
+                if(vkAllocateCommandBuffers(device, allocInfo, pCommandBuffers) != VK_SUCCESS) {
+                    throw new RuntimeException("Fialed to allocate command buffers");
+                }
+
+                for(int i = 0;i < commandBuffersCount;i++) {
+                    commandBuffers.add(new VkCommandBuffer(pCommandBuffers.get(i), device));
+                }
+
+                VkCommandBufferBeginInfo beginInfo = VkCommandBufferBeginInfo.callocStack(stack);
+                beginInfo.sType(VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO);
+
+                VkRenderPassBeginInfo renderPassInfo = VkRenderPassBeginInfo.callocStack(stack);
+                renderPassInfo.sType(VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO);
+                renderPassInfo.renderPass(renderPass);
+                VkRect2D renderArea = VkRect2D.callocStack(stack);
+                renderArea.offset(VkOffset2D.callocStack(stack).set(0, 0));
+                renderArea.extent(swapChainExtent);
+                renderPassInfo.renderArea(renderArea);
+                VkClearValue.Buffer clearValues = VkClearValue.callocStack(1, stack);
+                clearValues.color().float32(stack.floats(0.0f, 0.0f, 0.0f, 1.0f));
+                renderPassInfo.pClearValues(clearValues);
+
+                for(int i = 0;i < commandBuffersCount;i++) {
+
+                    VkCommandBuffer commandBuffer = commandBuffers.get(i);
+
+                    if(vkBeginCommandBuffer(commandBuffer, beginInfo) != VK_SUCCESS) {
+                        throw new RuntimeException("Failed to begin recording command buffer");
+                    }
+
+                    renderPassInfo.framebuffer(swapChainFramebuffers.get(i));
+
+
+                    vkCmdBeginRenderPass(commandBuffer, renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);
+                    {
+                        vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
+
+                        vkCmdDraw(commandBuffer, 3, 1, 0, 0);
+                    }
+                    vkCmdEndRenderPass(commandBuffer);
+
+
+                    if(vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
+                        throw new RuntimeException("Failed to record command buffer");
+                    }
+
+                }
+
+            }
+        }
+
         private long createShaderModule(ByteBuffer spirvCode) {
 
             try(MemoryStack stack = stackPush()) {
